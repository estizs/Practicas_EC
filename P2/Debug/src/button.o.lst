   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"button.c"
  21              	.Ltext0:
  22              		.file 1 "../src/button.c"
 1734              		.align	2
 1735              		.global	read_button
 1737              	read_button:
 1738              	.LFB0:
   1:../src/button.c **** /*-------------------------------------------------------------------
   2:../src/button.c **** **
   3:../src/button.c **** **  Fichero:
   4:../src/button.c **** **    button.c  10/6/2014
   5:../src/button.c **** **
   6:../src/button.c **** **    Estructura de Computadores
   7:../src/button.c **** **    Dpto. de Arquitectura de Computadores y Automï¿½tica
   8:../src/button.c **** **    Facultad de Informï¿½tica. Universidad Complutense de Madrid
   9:../src/button.c **** **
  10:../src/button.c **** **  Propï¿½sito:
  11:../src/button.c **** **    Contiene las implementaciones de las funciones
  12:../src/button.c **** **    para la gestiï¿½n de los pulsadores de la placa de prototipado
  13:../src/button.c **** **
  14:../src/button.c **** **  Notas de diseï¿½o:
  15:../src/button.c **** **
  16:../src/button.c **** **-----------------------------------------------------------------*/
  17:../src/button.c **** 
  18:../src/button.c **** #include "44b.h"
  19:../src/button.c **** #include "utils.h"
  20:../src/button.c **** #include "button.h"
  21:../src/button.c **** #include "leds.h"
  22:../src/button.c **** #include "gpio.h"
  23:../src/button.c **** 
  24:../src/button.c **** unsigned int read_button(void)
  25:../src/button.c **** {
 1739              		.loc 1 25 0
 1740              		.cfi_startproc
 1741              		@ Function supports interworking.
 1742              		@ args = 0, pretend = 0, frame = 8
 1743              		@ frame_needed = 1, uses_anonymous_args = 0
 1744 0000 0DC0A0E1 		mov	ip, sp
 1745              	.LCFI0:
 1746              		.cfi_def_cfa_register 12
 1747 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1748 0008 04B04CE2 		sub	fp, ip, #4
 1749              		.cfi_offset 14, -8
 1750              		.cfi_offset 13, -12
 1751              		.cfi_offset 11, -16
 1752              	.LCFI1:
 1753              		.cfi_def_cfa 11, 4
 1754 000c 08D04DE2 		sub	sp, sp, #8
  26:../src/button.c **** 	unsigned int buttons = 0;
 1755              		.loc 1 26 0
 1756 0010 0030A0E3 		mov	r3, #0
 1757 0014 10300BE5 		str	r3, [fp, #-16]
  27:../src/button.c **** 	enum digital val;
  28:../src/button.c **** 
  29:../src/button.c **** 	//COMPLETAR utilizando el interfaz del puerto G de gpio.h debemos leer los
  30:../src/button.c **** 	//pines 6 y 7 del puerto G (portG_read) debemos devolver un valor (buttons)
  31:../src/button.c **** 	//en el que el bit 0 (el menos significativo) representa el estado del botón
  32:../src/button.c **** 	//del pin 6 y el bit 1 representa el estado del botón del pin 7 (a 1 si
  33:../src/button.c **** 	//están pulsados a 0 si no lo están).
  34:../src/button.c **** 
  35:../src/button.c **** 	// Leemos la señal digital recibida en el pin 6
  36:../src/button.c **** 	portG_read(6, &val);
 1758              		.loc 1 36 0
 1759 0018 11304BE2 		sub	r3, fp, #17
 1760 001c 0600A0E3 		mov	r0, #6
 1761 0020 0310A0E1 		mov	r1, r3
 1762 0024 FEFFFFEB 		bl	portG_read
  37:../src/button.c **** 	// Si el botón está pulsado (a LOW) entonces lo señalamos en buttons y lo mismo para
  38:../src/button.c **** 	// el otro botón
  39:../src/button.c **** 	if(val == LOW)
 1763              		.loc 1 39 0
 1764 0028 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 1765 002c 000053E3 		cmp	r3, #0
 1766 0030 0300001A 		bne	.L2
  40:../src/button.c **** 		buttons = buttons | (0x1);
 1767              		.loc 1 40 0
 1768 0034 10301BE5 		ldr	r3, [fp, #-16]
 1769 0038 013083E3 		orr	r3, r3, #1
 1770 003c 10300BE5 		str	r3, [fp, #-16]
 1771 0040 020000EA 		b	.L3
 1772              	.L2:
  41:../src/button.c **** 	else
  42:../src/button.c **** 		buttons = buttons & ~(0x1);
 1773              		.loc 1 42 0
 1774 0044 10301BE5 		ldr	r3, [fp, #-16]
 1775 0048 0130C3E3 		bic	r3, r3, #1
 1776 004c 10300BE5 		str	r3, [fp, #-16]
 1777              	.L3:
  43:../src/button.c **** 	// Leemos la señal digital recibida en el pin 7
  44:../src/button.c **** 	portG_read(7, &val);
 1778              		.loc 1 44 0
 1779 0050 11304BE2 		sub	r3, fp, #17
 1780 0054 0700A0E3 		mov	r0, #7
 1781 0058 0310A0E1 		mov	r1, r3
 1782 005c FEFFFFEB 		bl	portG_read
  45:../src/button.c **** 	if(val == LOW)
 1783              		.loc 1 45 0
 1784 0060 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 1785 0064 000053E3 		cmp	r3, #0
 1786 0068 0300001A 		bne	.L4
  46:../src/button.c **** 		buttons = buttons | (0x1 << 1);
 1787              		.loc 1 46 0
 1788 006c 10301BE5 		ldr	r3, [fp, #-16]
 1789 0070 023083E3 		orr	r3, r3, #2
 1790 0074 10300BE5 		str	r3, [fp, #-16]
 1791 0078 020000EA 		b	.L5
 1792              	.L4:
  47:../src/button.c **** 	else
  48:../src/button.c **** 		buttons = buttons & ~(0x1 << 1);
 1793              		.loc 1 48 0
 1794 007c 10301BE5 		ldr	r3, [fp, #-16]
 1795 0080 0230C3E3 		bic	r3, r3, #2
 1796 0084 10300BE5 		str	r3, [fp, #-16]
 1797              	.L5:
  49:../src/button.c **** 
  50:../src/button.c **** 	return buttons;
 1798              		.loc 1 50 0
 1799 0088 10301BE5 		ldr	r3, [fp, #-16]
  51:../src/button.c **** }
 1800              		.loc 1 51 0
 1801 008c 0300A0E1 		mov	r0, r3
 1802 0090 0CD04BE2 		sub	sp, fp, #12
 1803 0094 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1804 0098 1EFF2FE1 		bx	lr
 1805              		.cfi_endproc
 1806              	.LFE0:
 1808              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 button.c
C:\Users\estib\AppData\Local\Temp\ccR4Re80.s:1734   .text:00000000 $a
C:\Users\estib\AppData\Local\Temp\ccR4Re80.s:1737   .text:00000000 read_button
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
portG_read
