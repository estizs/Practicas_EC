   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  21              	.Ltext0:
  22              		.file 1 "../src/main.c"
 2739              		.align	2
 2742              	RL:
 2743 0000 00000000 		.word	0
 2744 0004 05000000 		.word	5
 2745 0008 00000000 		.word	0
 2746 000c 00000000 		.word	0
 2747 0010 00000000 		.word	0
 2748 0014 00000000 		.word	0
 2749              		.text
 2750              		.align	2
 2751              		.global	setup
 2753              	setup:
 2754              	.LFB0:
   1:../src/main.c **** #include <stdio.h>
   2:../src/main.c **** #include "44b.h"
   3:../src/main.c **** #include "button.h"
   4:../src/main.c **** #include "leds.h"
   5:../src/main.c **** #include "utils.h"
   6:../src/main.c **** #include "D8Led.h"
   7:../src/main.c **** #include "gpio.h"
   8:../src/main.c **** 
   9:../src/main.c **** struct RLstat {
  10:../src/main.c **** 	int moving;
  11:../src/main.c **** 	int speed;
  12:../src/main.c **** 	int iter;
  13:../src/main.c **** 	int direction;
  14:../src/main.c **** 	int position;
  15:../src/main.c **** 	int contador;
  16:../src/main.c **** };
  17:../src/main.c **** 
  18:../src/main.c **** static struct RLstat RL = {
  19:../src/main.c **** 	.moving = 0,
  20:../src/main.c **** 	.speed = 5,
  21:../src/main.c **** 	.iter = 0,
  22:../src/main.c **** 	.direction = 0,
  23:../src/main.c **** 	.position = 0,
  24:../src/main.c **** 	.contador = 0,
  25:../src/main.c **** };
  26:../src/main.c **** 
  27:../src/main.c **** int setup(void)
  28:../src/main.c **** {
 2755              		.loc 1 28 0
 2756              		.cfi_startproc
 2757              		@ Function supports interworking.
 2758              		@ args = 0, pretend = 0, frame = 0
 2759              		@ frame_needed = 1, uses_anonymous_args = 0
 2760 0000 0DC0A0E1 		mov	ip, sp
 2761              	.LCFI0:
 2762              		.cfi_def_cfa_register 12
 2763 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2764 0008 04B04CE2 		sub	fp, ip, #4
 2765              		.cfi_offset 14, -8
 2766              		.cfi_offset 13, -12
 2767              		.cfi_offset 11, -16
 2768              	.LCFI1:
 2769              		.cfi_def_cfa 11, 4
  29:../src/main.c **** 	leds_init();
 2770              		.loc 1 29 0
 2771 000c FEFFFFEB 		bl	leds_init
  30:../src/main.c **** 	D8Led_init();
 2772              		.loc 1 30 0
 2773 0010 FEFFFFEB 		bl	D8Led_init
  31:../src/main.c **** 	D8Led_segment(RL.position);
 2774              		.loc 1 31 0
 2775 0014 54309FE5 		ldr	r3, .L2
 2776 0018 103093E5 		ldr	r3, [r3, #16]
 2777 001c 0300A0E1 		mov	r0, r3
 2778 0020 FEFFFFEB 		bl	D8Led_segment
  32:../src/main.c **** 
  33:../src/main.c **** 	/* Port G: configuración para espera activa */
  34:../src/main.c **** 
  35:../src/main.c **** 	//COMPLETAR: utilizando el interfaz para el puerto G definido en gpio.h hay
  36:../src/main.c **** 	//que configurar los pines 6 y 7 del puerto G como pines de entrada y
  37:../src/main.c **** 	//activar las correspondientes resistencias de pull-up
  38:../src/main.c **** 	
  39:../src/main.c **** 	// Pines 6 y 7 como input
  40:../src/main.c **** 	portG_conf(6, INPUT);
 2779              		.loc 1 40 0
 2780 0024 0600A0E3 		mov	r0, #6
 2781 0028 0010A0E3 		mov	r1, #0
 2782 002c FEFFFFEB 		bl	portG_conf
  41:../src/main.c **** 	portG_conf(7, INPUT);
 2783              		.loc 1 41 0
 2784 0030 0700A0E3 		mov	r0, #7
 2785 0034 0010A0E3 		mov	r1, #0
 2786 0038 FEFFFFEB 		bl	portG_conf
  42:../src/main.c **** 	// Activar pull-up
  43:../src/main.c **** 	portG_conf_pup(6, ENABLE);
 2787              		.loc 1 43 0
 2788 003c 0600A0E3 		mov	r0, #6
 2789 0040 0110A0E3 		mov	r1, #1
 2790 0044 FEFFFFEB 		bl	portG_conf_pup
  44:../src/main.c **** 	portG_conf_pup(7, ENABLE);
 2791              		.loc 1 44 0
 2792 0048 0700A0E3 		mov	r0, #7
 2793 004c 0110A0E3 		mov	r1, #1
 2794 0050 FEFFFFEB 		bl	portG_conf_pup
  45:../src/main.c **** 
  46:../src/main.c **** 	/*******************************************/
  47:../src/main.c **** 
  48:../src/main.c **** 	Delay(0);
 2795              		.loc 1 48 0
 2796 0054 0000A0E3 		mov	r0, #0
 2797 0058 FEFFFFEB 		bl	Delay
  49:../src/main.c **** 	return 0;
 2798              		.loc 1 49 0
 2799 005c 0030A0E3 		mov	r3, #0
  50:../src/main.c **** }
 2800              		.loc 1 50 0
 2801 0060 0300A0E1 		mov	r0, r3
 2802 0064 0CD04BE2 		sub	sp, fp, #12
 2803 0068 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2804 006c 1EFF2FE1 		bx	lr
 2805              	.L3:
 2806              		.align	2
 2807              	.L2:
 2808 0070 00000000 		.word	RL
 2809              		.cfi_endproc
 2810              	.LFE0:
 2812              		.align	2
 2813              		.global	loop
 2815              	loop:
 2816              	.LFB1:
  51:../src/main.c **** 
  52:../src/main.c **** int loop(void)
  53:../src/main.c **** {
 2817              		.loc 1 53 0
 2818              		.cfi_startproc
 2819              		@ Function supports interworking.
 2820              		@ args = 0, pretend = 0, frame = 8
 2821              		@ frame_needed = 1, uses_anonymous_args = 0
 2822 0074 0DC0A0E1 		mov	ip, sp
 2823              	.LCFI2:
 2824              		.cfi_def_cfa_register 12
 2825 0078 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2826 007c 04B04CE2 		sub	fp, ip, #4
 2827              		.cfi_offset 14, -8
 2828              		.cfi_offset 13, -12
 2829              		.cfi_offset 11, -16
 2830              	.LCFI3:
 2831              		.cfi_def_cfa 11, 4
 2832 0080 08D04DE2 		sub	sp, sp, #8
  54:../src/main.c **** 	unsigned int buttons = read_button();
 2833              		.loc 1 54 0
 2834 0084 FEFFFFEB 		bl	read_button
 2835 0088 10000BE5 		str	r0, [fp, #-16]
  55:../src/main.c **** 
  56:../src/main.c **** 	if (buttons & BUT1) {
 2836              		.loc 1 56 0
 2837 008c 10301BE5 		ldr	r3, [fp, #-16]
 2838 0090 013003E2 		and	r3, r3, #1
 2839 0094 FF3003E2 		and	r3, r3, #255
 2840 0098 000053E3 		cmp	r3, #0
 2841 009c 0C00000A 		beq	.L5
  57:../src/main.c **** 		// COMPLETAR: utilizando la interfaz para los leds definida en leds.h
  58:../src/main.c **** 		// hay que apagar ambos leds
  59:../src/main.c **** 		// También hay que conmutar la dirección del movimiento del led rotante
  60:../src/main.c **** 		// representado por el campo direction de la variable RL
  61:../src/main.c **** 
  62:../src/main.c **** 		// Apagamos los leds
  63:../src/main.c **** 		led1_off();
 2842              		.loc 1 63 0
 2843 00a0 FEFFFFEB 		bl	led1_off
  64:../src/main.c **** 		led2_off();
 2844              		.loc 1 64 0
 2845 00a4 FEFFFFEB 		bl	led2_off
  65:../src/main.c **** 		// Invertimos la dirección del RL
  66:../src/main.c **** 		if(RL.direction) RL.direction = 0;
 2846              		.loc 1 66 0
 2847 00a8 98319FE5 		ldr	r3, .L17
 2848 00ac 0C3093E5 		ldr	r3, [r3, #12]
 2849 00b0 000053E3 		cmp	r3, #0
 2850 00b4 0300000A 		beq	.L6
 2851              		.loc 1 66 0 is_stmt 0 discriminator 1
 2852 00b8 88319FE5 		ldr	r3, .L17
 2853 00bc 0020A0E3 		mov	r2, #0
 2854 00c0 0C2083E5 		str	r2, [r3, #12]
 2855 00c4 020000EA 		b	.L5
 2856              	.L6:
  67:../src/main.c **** 		else RL.direction = 1;
 2857              		.loc 1 67 0 is_stmt 1
 2858 00c8 78319FE5 		ldr	r3, .L17
 2859 00cc 0120A0E3 		mov	r2, #1
 2860 00d0 0C2083E5 		str	r2, [r3, #12]
 2861              	.L5:
  68:../src/main.c **** 	}
  69:../src/main.c **** 
  70:../src/main.c **** 	if (buttons & BUT2) {
 2862              		.loc 1 70 0
 2863 00d4 10301BE5 		ldr	r3, [fp, #-16]
 2864 00d8 023003E2 		and	r3, r3, #2
 2865 00dc 000053E3 		cmp	r3, #0
 2866 00e0 1F00000A 		beq	.L7
  71:../src/main.c **** 		// COMPLETAR: utilizando la interfaz para los leds definida en leds.h
  72:../src/main.c **** 		// Incrementar contador de pulsaciones. Si es par, conmutar led1. Si es impar, conmutar el led2.
  73:../src/main.c **** 		// También hay que comutar el estado de movimiento del led rotante
  74:../src/main.c **** 		// representado por el campo moving de la variable RL, y en caso de
  75:../src/main.c **** 		// ponerlo en marcha debemos reiniciar el campo iter al valor del campo
  76:../src/main.c **** 		// speed.
  77:../src/main.c **** 		++RL.contador;
 2867              		.loc 1 77 0
 2868 00e4 5C319FE5 		ldr	r3, .L17
 2869 00e8 143093E5 		ldr	r3, [r3, #20]
 2870 00ec 012083E2 		add	r2, r3, #1
 2871 00f0 50319FE5 		ldr	r3, .L17
 2872 00f4 142083E5 		str	r2, [r3, #20]
  78:../src/main.c **** 		if(RL.contador % 2 == 0) // Si este es par entonces conmuto el LED1
 2873              		.loc 1 78 0
 2874 00f8 48319FE5 		ldr	r3, .L17
 2875 00fc 143093E5 		ldr	r3, [r3, #20]
 2876 0100 013003E2 		and	r3, r3, #1
 2877 0104 000053E3 		cmp	r3, #0
 2878 0108 0100001A 		bne	.L8
  79:../src/main.c **** 			led1_switch();
 2879              		.loc 1 79 0
 2880 010c FEFFFFEB 		bl	led1_switch
 2881 0110 000000EA 		b	.L9
 2882              	.L8:
  80:../src/main.c **** 		else // Si es impar conmuto LED2
  81:../src/main.c **** 			led2_switch();
 2883              		.loc 1 81 0
 2884 0114 FEFFFFEB 		bl	led2_switch
 2885              	.L9:
  82:../src/main.c **** 		// Conmuto el campo moving
  83:../src/main.c **** 		if(RL.moving) RL.moving = 0;
 2886              		.loc 1 83 0
 2887 0118 28319FE5 		ldr	r3, .L17
 2888 011c 003093E5 		ldr	r3, [r3, #0]
 2889 0120 000053E3 		cmp	r3, #0
 2890 0124 0300000A 		beq	.L10
 2891              		.loc 1 83 0 is_stmt 0 discriminator 1
 2892 0128 18319FE5 		ldr	r3, .L17
 2893 012c 0020A0E3 		mov	r2, #0
 2894 0130 002083E5 		str	r2, [r3, #0]
 2895 0134 020000EA 		b	.L11
 2896              	.L10:
  84:../src/main.c **** 		else RL.moving = 1;
 2897              		.loc 1 84 0 is_stmt 1
 2898 0138 08319FE5 		ldr	r3, .L17
 2899 013c 0120A0E3 		mov	r2, #1
 2900 0140 002083E5 		str	r2, [r3, #0]
 2901              	.L11:
  85:../src/main.c **** 		// Si se pone en marcha reset a iter con el valor por defecto de speed
  86:../src/main.c **** 		if(RL.moving)
 2902              		.loc 1 86 0
 2903 0144 FC309FE5 		ldr	r3, .L17
 2904 0148 003093E5 		ldr	r3, [r3, #0]
 2905 014c 000053E3 		cmp	r3, #0
 2906 0150 0300000A 		beq	.L7
  87:../src/main.c **** 			RL.iter = RL.speed;
 2907              		.loc 1 87 0
 2908 0154 EC309FE5 		ldr	r3, .L17
 2909 0158 042093E5 		ldr	r2, [r3, #4]
 2910 015c E4309FE5 		ldr	r3, .L17
 2911 0160 082083E5 		str	r2, [r3, #8]
 2912              	.L7:
  88:../src/main.c **** 	}
  89:../src/main.c **** 
  90:../src/main.c **** 	if (RL.moving) {
 2913              		.loc 1 90 0
 2914 0164 DC309FE5 		ldr	r3, .L17
 2915 0168 003093E5 		ldr	r3, [r3, #0]
 2916 016c 000053E3 		cmp	r3, #0
 2917 0170 2900000A 		beq	.L12
  91:../src/main.c **** 		RL.iter--;
 2918              		.loc 1 91 0
 2919 0174 CC309FE5 		ldr	r3, .L17
 2920 0178 083093E5 		ldr	r3, [r3, #8]
 2921 017c 012043E2 		sub	r2, r3, #1
 2922 0180 C0309FE5 		ldr	r3, .L17
 2923 0184 082083E5 		str	r2, [r3, #8]
  92:../src/main.c **** 		if (RL.iter == 0) {
 2924              		.loc 1 92 0
 2925 0188 B8309FE5 		ldr	r3, .L17
 2926 018c 083093E5 		ldr	r3, [r3, #8]
 2927 0190 000053E3 		cmp	r3, #0
 2928 0194 2000001A 		bne	.L12
  93:../src/main.c **** 			// COMPLETAR: debemos hacer avanzar el led rotante una posición en
  94:../src/main.c **** 			// la dirección indicada por el campo direction de la variable RL.
  95:../src/main.c **** 			// La posición actual está representada en el campo position.
  96:../src/main.c **** 			// Recordar que queremos un movimiento circular, representado por
  97:../src/main.c **** 			// las 6 primeras posiciones en el array Segmentes del display de 8
  98:../src/main.c **** 			// segmentos, por lo que position debe estar siempre entre 0 y 5.
  99:../src/main.c **** 			
 100:../src/main.c **** 			// Como queremos que sea circular entonces tenemos que hacerlo módulo el tamaño
 101:../src/main.c **** 			// La fórmula general (independientemente de la dirección) es: pos = (pos+/-1) % 5;
 102:../src/main.c **** 			// Si la dirección es 0 => sentido antihorario entonces es pos - 1
 103:../src/main.c **** 			// En cambio si la dirección es 1 => sentido horario por lo que pos + 1
 104:../src/main.c **** 			if(RL.direction) ++RL.position;
 2929              		.loc 1 104 0
 2930 0198 A8309FE5 		ldr	r3, .L17
 2931 019c 0C3093E5 		ldr	r3, [r3, #12]
 2932 01a0 000053E3 		cmp	r3, #0
 2933 01a4 0500000A 		beq	.L13
 2934              		.loc 1 104 0 is_stmt 0 discriminator 1
 2935 01a8 98309FE5 		ldr	r3, .L17
 2936 01ac 103093E5 		ldr	r3, [r3, #16]
 2937 01b0 012083E2 		add	r2, r3, #1
 2938 01b4 8C309FE5 		ldr	r3, .L17
 2939 01b8 102083E5 		str	r2, [r3, #16]
 2940 01bc 040000EA 		b	.L14
 2941              	.L13:
 105:../src/main.c **** 			else --RL.position;
 2942              		.loc 1 105 0 is_stmt 1
 2943 01c0 80309FE5 		ldr	r3, .L17
 2944 01c4 103093E5 		ldr	r3, [r3, #16]
 2945 01c8 012043E2 		sub	r2, r3, #1
 2946 01cc 74309FE5 		ldr	r3, .L17
 2947 01d0 102083E5 		str	r2, [r3, #16]
 2948              	.L14:
 106:../src/main.c **** 			if(RL.position < 0) RL.position = 5;
 2949              		.loc 1 106 0
 2950 01d4 6C309FE5 		ldr	r3, .L17
 2951 01d8 103093E5 		ldr	r3, [r3, #16]
 2952 01dc 000053E3 		cmp	r3, #0
 2953 01e0 020000AA 		bge	.L15
 2954              		.loc 1 106 0 is_stmt 0 discriminator 1
 2955 01e4 5C309FE5 		ldr	r3, .L17
 2956 01e8 0520A0E3 		mov	r2, #5
 2957 01ec 102083E5 		str	r2, [r3, #16]
 2958              	.L15:
 107:../src/main.c **** 			if(RL.position > 5) RL.position = 0;
 2959              		.loc 1 107 0 is_stmt 1
 2960 01f0 50309FE5 		ldr	r3, .L17
 2961 01f4 103093E5 		ldr	r3, [r3, #16]
 2962 01f8 050053E3 		cmp	r3, #5
 2963 01fc 020000DA 		ble	.L16
 2964              		.loc 1 107 0 is_stmt 0 discriminator 1
 2965 0200 40309FE5 		ldr	r3, .L17
 2966 0204 0020A0E3 		mov	r2, #0
 2967 0208 102083E5 		str	r2, [r3, #16]
 2968              	.L16:
 108:../src/main.c **** 			RL.iter = RL.speed;
 2969              		.loc 1 108 0 is_stmt 1
 2970 020c 34309FE5 		ldr	r3, .L17
 2971 0210 042093E5 		ldr	r2, [r3, #4]
 2972 0214 2C309FE5 		ldr	r3, .L17
 2973 0218 082083E5 		str	r2, [r3, #8]
 2974              	.L12:
 109:../src/main.c **** 		}
 110:../src/main.c **** 	}
 111:../src/main.c **** 	D8Led_segment(RL.position);
 2975              		.loc 1 111 0
 2976 021c 24309FE5 		ldr	r3, .L17
 2977 0220 103093E5 		ldr	r3, [r3, #16]
 2978 0224 0300A0E1 		mov	r0, r3
 2979 0228 FEFFFFEB 		bl	D8Led_segment
 112:../src/main.c **** 	Delay(2000); // espera de 200ms para que el bucle se repita 5 veces por segundo
 2980              		.loc 1 112 0
 2981 022c 7D0EA0E3 		mov	r0, #2000
 2982 0230 FEFFFFEB 		bl	Delay
 113:../src/main.c **** 	return 0;
 2983              		.loc 1 113 0
 2984 0234 0030A0E3 		mov	r3, #0
 114:../src/main.c **** }
 2985              		.loc 1 114 0
 2986 0238 0300A0E1 		mov	r0, r3
 2987 023c 0CD04BE2 		sub	sp, fp, #12
 2988 0240 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2989 0244 1EFF2FE1 		bx	lr
 2990              	.L18:
 2991              		.align	2
 2992              	.L17:
 2993 0248 00000000 		.word	RL
 2994              		.cfi_endproc
 2995              	.LFE1:
 2997              		.align	2
 2998              		.global	main
 3000              	main:
 3001              	.LFB2:
 115:../src/main.c **** 
 116:../src/main.c **** 
 117:../src/main.c **** int main(void)
 118:../src/main.c **** {
 3002              		.loc 1 118 0
 3003              		.cfi_startproc
 3004              		@ Function supports interworking.
 3005              		@ args = 0, pretend = 0, frame = 0
 3006              		@ frame_needed = 1, uses_anonymous_args = 0
 3007 024c 0DC0A0E1 		mov	ip, sp
 3008              	.LCFI4:
 3009              		.cfi_def_cfa_register 12
 3010 0250 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3011 0254 04B04CE2 		sub	fp, ip, #4
 3012              		.cfi_offset 14, -8
 3013              		.cfi_offset 13, -12
 3014              		.cfi_offset 11, -16
 3015              	.LCFI5:
 3016              		.cfi_def_cfa 11, 4
 119:../src/main.c **** 	setup();
 3017              		.loc 1 119 0
 3018 0258 FEFFFFEB 		bl	setup
 3019              	.L20:
 120:../src/main.c **** 
 121:../src/main.c **** 	while (1) {
 122:../src/main.c **** 		loop();
 3020              		.loc 1 122 0 discriminator 1
 3021 025c FEFFFFEB 		bl	loop
 123:../src/main.c **** 	}
 3022              		.loc 1 123 0 discriminator 1
 3023 0260 FDFFFFEA 		b	.L20
 3024              		.cfi_endproc
 3025              	.LFE2:
 3027              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:2739   .data:00000000 $d
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:2742   .data:00000000 RL
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:2750   .text:00000000 $a
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:2753   .text:00000000 setup
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:2808   .text:00000070 $d
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:2812   .text:00000074 $a
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:2815   .text:00000074 loop
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:2993   .text:00000248 $d
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:2997   .text:0000024c $a
C:\Users\estib\AppData\Local\Temp\cc1utjiX.s:3000   .text:0000024c main
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
leds_init
D8Led_init
D8Led_segment
portG_conf
portG_conf_pup
Delay
read_button
led1_off
led2_off
led1_switch
led2_switch
